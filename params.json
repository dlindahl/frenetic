{"name":"Frenetic","tagline":"A Ruby-based Hypermedia API client.","body":"# Frenetic  [![Gem Version][version_badge]][version] [![Build Status][travis_status]][travis]\r\n\r\n[version_badge]: https://badge.fury.io/rb/frenetic.png\r\n[version]: http://badge.fury.io/rb/frenetic\r\n[travis_status]: https://secure.travis-ci.org/dlindahl/frenetic.png\r\n[travis]: http://travis-ci.org/dlindahl/frenetic\r\n\r\nAn opinionated Ruby-based Hypermedia API (HAL+JSON) client.\r\n\r\n\r\n\r\n\r\n## About\r\n\r\nfre&bull;net&bull;ic |frəˈnetik|<br/>\r\nadjective<br/>\r\nfast and energetic in a rather wild and uncontrolled way : *a frenetic pace of activity.*\r\n\r\nSo basically, this is a crazy way to interact with your Hypermedia HAL+JSON API.\r\n\r\nGet it? *Hypermedia*?\r\n\r\n*Hyper*?\r\n\r\n...\r\n\r\nIf you have not implemented a HAL+JSON API, then this will not work very well for you.\r\n\r\n\r\n\r\n\r\n## Opinions\r\n\r\nLike I said, it is opinionated. It is so opinionated, it is probably the biggest\r\na-hole you've ever met.\r\n\r\nMaybe in time, if you teach it, it will become more open-minded.\r\n\r\n\r\n\r\n### HAL+JSON Content Type\r\n\r\nFrenetic expects all responses to be in [HAL+JSON][hal_json]. It chose that\r\nstandard because it is trying to make JSON API's respond in a predictable\r\nmanner, which it thinks is an awesome idea.\r\n\r\n\r\n\r\n### Authentication\r\n\r\nFrenetic is going to try and use Basic Auth whether you like it or not. If\r\nthat is not required, nothing will probably happen. But its going to send the\r\nheader anyway.\r\n\r\n\r\n\r\n### API Description\r\n\r\nThe API's root URL must respond with a description, much like the\r\n[Spire.io][spire.io] API. This is crucial in order for Frenetic to work. If\r\nFrenetic doesn't know what the API contains, it can't parse any resource\r\nresponses.\r\n\r\nIt is expected that any subclasses of `Frenetic::Resource` will adhere to the\r\nschema defined here.\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"_links\":{\r\n    \"self\":{\"href\":\"/api/\"},\r\n    \"orders\":{\"href\":\"/api/orders\"},\r\n  },\r\n  \"_embedded\":{\r\n    \"schema\":{\r\n      \"_links\":{\r\n        \"self\":{\"href\":\"/api/schema\"}\r\n      },\r\n      \"order\":{\r\n        \"description\":\"A widget order\",\r\n        \"type\":\"object\",\r\n        \"properties\":{\r\n          \"id\":{\"type\":\"integer\"},\r\n          \"first_name\":{\"type\":\"string\"},\r\n          \"last_name\":{\"type\":\"string\"},\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis response will be requested by Frenetic whenever a call to\r\n`YourAPI.description` is made. The response is memoized so any future calls\r\nwill not trigger another API request.\r\n\r\n\r\n\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'frenetic'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install frenetic\r\n\r\n\r\n\r\n\r\n## Usage\r\n\r\n\r\n\r\n### Client Initialization\r\n\r\n```ruby\r\nMyAPI = Frenetic.new(\r\n  # 'adapter'    => :patron # Or some other Faraday-compatible Adapter. Defaults to `:net_http`\r\n  'url'          => 'https://api.yoursite.com',\r\n  'username'     => 'yourname',\r\n  'password'     => 'yourpassword',\r\n  'headers' => {\r\n    'accept' => 'application/vnd.yoursite-v1.hal+json'\r\n    # Optional\r\n    'user-agent' => 'Your Site's API Client', # Optional custom User Agent, just 'cuz\r\n  }\r\n)\r\n```\r\n\r\nSymbol- or string-based keys work equally well.\r\n\r\n#### Sending API Keys\r\n\r\nIf the API you are consuming requires an API Key, you can provide that in the\r\nconfig hash:\r\n\r\n```ruby\r\nFrenetic.new( url:'https://example.org', api_key:'abcde12345' )\r\n```\r\n\r\nThe value will be sent as the `:username` portion of the HTTP\r\nBasic Authentication header.\r\n\r\n#### Sending API Keys with an App ID\r\n\r\nIf the API requires both an App ID or access token in addition to an API Key,\r\nyou can provide that in the config hash as well:\r\n\r\n```ruby\r\nFrenetic.new( url:'https://example.org', app_id:'abcde12345', api_key:'mysecret' )\r\n```\r\n\r\nThe App ID will be sent as the `:username` and the API Key will be sent as the\r\npassword portion of the HTTP Basic Authentication header.\r\n\r\n\r\n\r\n### Response Caching\r\n\r\nIf configured to do so, Frenetic will autotmatically cache appropriate responses\r\nthrough [Rack::Cache][rack_cache]. Only on-disk stores are supported right now.\r\n\r\nAdd the following `Rack::Cache` configuration options when initializing Frenetic:\r\n\r\n```ruby\r\nMyAPI = Frenetic.new(\r\n  ...\r\n  'cache' => {\r\n    'metastore'   => 'file:/path/to/where/you/want/to/store/files/meta',\r\n    'entitystore' => 'file:/path/to/where/you/want/to/store/files/meta'\r\n  }\r\n)\r\n```\r\n\r\nThe `cache` options are passed directly to `Rack::Cache`, so anything it\r\nsupports can be added to the Hash.\r\n\r\n\r\n\r\n# Middleware\r\n\r\nFrenetic supports anything that Faraday does. You may specify additional\r\nmiddleware with the `use` method:\r\n\r\n```ruby\r\nFrenetic.new( url:'http://example.org' ) do |config|\r\n  config.use :instrumentation\r\n  config.use MyMiddleware, { foo:123 }\r\nend\r\n```\r\n\r\n\r\n\r\n### Making Requests\r\n\r\nOnce you have created a client instance, you are free to use it however you'd\r\nlike.\r\n\r\nA Frenetic instance supports any HTTP verb that [Faraday][faraday] has\r\nimpletented. This includes GET, POST, PUT, PATCH, and DELETE.\r\n\r\n\r\n\r\n#### Frenetic::Resource\r\n\r\nAn easier way to make requests for a resource is to have your model inherit from\r\n`Frenetic::Resource`. This makes it a bit easier to encapsulate all of your\r\nresource's API requests into one place.\r\n\r\n```ruby\r\nclass Order < Frenetic::Resource\r\n\r\n  api_client { MyAPI }\r\n\r\n  class << self\r\n    def find( id )\r\n      if response = api.get( api.description.links.order.href.gsub('{id}', id.to_s) ) and response.success?\r\n        self.new( response.body )\r\n      else\r\n        raise OrderNotFound, \"No Order found for #{id}\"\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe `api_client` class method merely tells `Frenetic::Resource` which API Client\r\ninstance to use. If you lazily instantiate your client, then you should pass a\r\nblock as demonstrated above.\r\n\r\nOtherwise, you may pass by reference:\r\n\r\n```ruby\r\nclass Order < Frenetic::Resource\r\n  api_client MyAPI\r\nend\r\n```\r\n\r\nWhen your model is initialized, it will contain attribute readers for every\r\nproperty defined in your API's schema or description. In theory, this allows an\r\nAPI to add, remove, or change properties without the need to directly update\r\nyour model.\r\n\r\n\r\n\r\n### Interpretting Responses\r\n\r\nAny response body returned by a Frenetic generated API call will be returned as\r\nan OpenStruct-like object. This object responds to dot-notation as well as Hash\r\nkeys and is enumerable.\r\n\r\n```ruby\r\nresponse.body.resources.orders.first\r\n```\r\n\r\nor\r\n\r\n```ruby\r\nresponse.body['_embedded']['orders'][0]\r\n```\r\n\r\nFor your convenience, certain HAL+JSON keys have been aliased by methods to\r\nmake your code a bit more readable:\r\n\r\n  * `_embedded` can be referenced as `resources`\r\n  * `_links` can be referenced as `links`\r\n  * `href` can be referenced as `url`\r\n\r\n\r\n\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n[hal_json]: http://stateless.co/hal_specification.html\r\n[spire.io]: http://api.spire.io/\r\n[roar]: https://github.com/apotonick/roar\r\n[faraday]: https://github.com/technoweenie/faraday\r\n[rack_cache]: https://github.com/rtomayko/rack-cache\r\n","google":"UA-30792571-1","note":"Don't delete this file! It's used internally to help with page regeneration."}